package rait

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"strings"
	"text/template"
)

const BabeldConfigTemplate = `# generated by rait
random-id true
export-table 254

default type tunnel link-quality true split-horizon false
default rxcost 32 hello-interval 20 max-rtt-penalty 1024 rtt-max 1024

{{if .VethName}}interface {{.VethName}} link-quality false rxcost 1 hello-interval 4{{end}}
{{range $name := .IFName}}interface {{$name}}
{{end}}
redistribute local deny
`

func (r *RAIT) GenerateBabeldConfig() error {
	if r.Babeld == "off" {
		return nil
	}
	helper, err := NamespaceHelperFromName(r.Namespace)
	if err != nil {
		return fmt.Errorf("GenerateBabeldConfig: failed to get netns helper: %w", err)
	}
	defer helper.Destroy()
	linkList, err := helper.DstHandle.LinkList()
	if err != nil {
		return fmt.Errorf("GenerateBabeldConfig: failed to list links: %w", err)
	}
	var IFName []string
	for _, link := range linkList {
		if link.Type() == "wireguard" && strings.HasPrefix(link.Attrs().Name, r.IFPrefix) {
			IFName = append(IFName, link.Attrs().Name)
		}
	}
	tmpl, err := template.New("babeld.conf").Parse(BabeldConfigTemplate)
	if err != nil {
		return fmt.Errorf("GenerateBabeldConfig: failed to parse config template: %w", err)
	}
	var conf bytes.Buffer
	var vethname string
	if r.Veth != "off" {
		vethname = r.Veth + "host"
	}
	err = tmpl.Execute(&conf, struct {
		IFName   []string
		VethName string
	}{IFName: IFName, VethName: vethname})
	if err != nil {
		return fmt.Errorf("GenerateBabeldConfig: failed to execute config template: %w", err)
	}
	err = CreateParentDirIfNotExist(r.Babeld)
	if err != nil {
		return fmt.Errorf("GenerateBabeldConfig: failed to create parent directory for babeld.conf: %w", err)
	}
	err = ioutil.WriteFile(r.Babeld, conf.Bytes(), 0644)
	if err != nil {
		return fmt.Errorf("GenerateBabeldConfig: failed to write babeld.conf: %w", err)
	}
	return nil
}
